<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Frances Hu's Blog">
<meta property="og:url" content="http://xiaozhazi.github.io/index.html">
<meta property="og:site_name" content="Frances Hu's Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Frances Hu's Blog">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://xiaozhazi.github.io/"/>

  <title> Frances Hu's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Frances Hu's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Born to be wild!</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/12/25/学习笔记W2/" itemprop="url">
                  学习笔记W2
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2020-12-25T22:00:00+08:00" content="2020-12-25">
              2020-12-25
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="笔记汇总"><a href="#笔记汇总" class="headerlink" title="笔记汇总"></a>笔记汇总</h2><h3 id="1-K8S垃圾收集器"><a href="#1-K8S垃圾收集器" class="headerlink" title="1. K8S垃圾收集器"></a>1. K8S垃圾收集器</h3><p><a href="https://draveness.me/kubernetes-garbage-collector/" target="_blank" rel="external">详解Kubernetes垃圾收集器的实现原理</a></p>
<p>垃圾收集器在K8S中以控制器的形式设计实现，删除以前有所有者但是现在所有者不存在的对象。引入垃圾收集器之前，所有的级联删除逻辑都由客户端完成，垃圾收集器的引入使得级联删除实现移动到了服务端。</p>
<p>级联删除： 对象的API中加入了metadata.ownerReferences字段，包含当前对象的所有依赖者。当所有依赖者都被删除，默认情况下该对象也会被删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">type ObjectMeta struct &#123;</div><div class="line">	...</div><div class="line">	OwnerReferences []OwnerReference</div><div class="line">&#125;</div><div class="line">type OwnerReference struct &#123;</div><div class="line">	APIVersion string</div><div class="line">	Kind string</div><div class="line">	Name string</div><div class="line">	UID types.UID</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>GarbageCollector负责处理对象之间的联系并在所有依赖者不存在时将对象删除。其中包含了一个GraphBuilder结构体，该结构体会以Goroutine的形式运行使用Informer监听集群中几乎全部资源变动，一但发生变更事件，就将该事件交给主循环体处理。主循环体根据事件的不同选择将处理对象加入不同的队列，GarbageCollector持有的另外两组队列会负责删除或孤立目标对象。</p>
<ul>
<li><p>attemptToDeleteItem ： 首先获取待处理对象及其ownerReferences列表，使用classifyReferences将所有者进行分类处理：</p>
<ul>
<li>所有者还有存在于集群中的，当前对象不会被删除。将已经被删除、等待删除的所有者从对象ownerReferences删除；</li>
<li>当正在被删除的所有者不存在任何依赖且ownerReference.blockOwnerDeletion=true时会阻止依赖方的删除，当前对象会等待ownerReference.blockOwnerDeletion=true的所有对象删除后才会被删除；</li>
<li><p>当前对象不包含任何依赖，会选择三种不同的策略处理依赖：</p>
<ul>
<li>当前对象有FinalizerOrphanDependents终结器，DeletePropagationOrphan将对象的所有依赖者变成孤立的；</li>
<li>当前对象有FinalizerDeleteDependents终接器，deletePropagationBackground策略在前台等待所有依赖被删除后才会删除，整个过程是同步的；</li>
<li>默认情况下使用DeletePropagationDefault策略在后台删除当前对象的所有依赖；</li>
</ul>
</li>
</ul>
</li>
<li>attemptToOrphanItem</li>
</ul>
<h3 id="2-Go-Select实现原理"><a href="#2-Go-Select实现原理" class="headerlink" title="2. Go Select实现原理"></a>2. Go Select实现原理</h3><p><a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-select/" target="_blank" rel="external">Go 语言select实现原理</a></p>
<p>Go语言中select能够让Goroutine同时等待多个Channel的可读/可写，在Channel发生状态改变之前会一直阻塞当前Goroutine。其与switch不同的是，case中的表达式必须是Channel的收发操作。</p>
<ul>
<li><strong>select 能在 Channel 上进行非阻塞的收发操作</strong>；</li>
<li><strong>select 在遇到多个 Channel 同时响应时会随机挑选 case 执行</strong>；(随机的引入是为了避免饥饿问题)</li>
</ul>
<p>通常情况下select语句会阻塞当前Goroutine并等待多个Channel中一个达到可以收发的状态，但是如果存在default：</p>
<ul>
<li>当存在可以收发的Channel时，直接处理该Channel对应的case； </li>
<li>当不存在可以收发的Channel时，执行default中语句；<br>非阻塞的Channel发送和接收操作还是很有必要的，在很多场景下我们不希望向Channel发送消息或者从Channel中接收消息会阻塞当前Goroutine，只是想看看 Channel的可读或者可写状态。</li>
</ul>
<p>编译器在中间代码生成期间会根据select中case的不同对控制语句进行优化，这一过程都发生在 cmd/compile/internal/gc.walkselectcases 函数中：</p>
<ul>
<li>select 不存在任何的 case； 将select{}转换为调用runtime.block，通过gopark让出当前Goroutine对处理器的使用权，导致当前G进入无法被唤醒的永久休眠状态</li>
<li>select 只存在一个 case； 将select改写成if条件预计，当case中Channel是空指针时，挂起当前G并永久休眠</li>
<li><p>select 存在两个 case，其中一个 case 是 default； </p>
<ul>
<li>非阻塞发送：编译器使用if else改写代码，selectnbsend向Channel非阻塞发送数据，即向chansend函数传入false，哪怕不存在接收方或者缓冲区空间不足都不会阻塞当前G，直接返回。</li>
<li>非阻塞接收：根据接收数据返回值数量的不同使用selectnbrecv或者selectnbrecv2对返回值进行处理</li>
</ul>
</li>
<li><p>select 存在多个 case； </p>
<p>  将所有case转换成包含Channel以及类型信息的runtime.scase结构体，调用runtime.selectgo选择一个可执行的scase。runtime.selectgo 函数首先会进行执行必要的初始化操作并决定处理 case 的两个顺序 — <strong>轮询顺序 pollOrder 和加锁顺序 lockOrder：</strong></p>
<ul>
<li>轮询顺序：通过 runtime.fastrandn 函数引入随机性； (避免Channel饥饿问题保证公平)</li>
<li>加锁顺序：按照 Channel 的地址排序后确定加锁顺序；(避免死锁)</li>
</ul>
</li>
</ul>
<p>selectgo 处理流程    </p>
<ul>
<li>随机生成一个遍历的轮询顺序pollOrder 并根据Channel地址生成锁定顺序lockOrder；</li>
<li>根据pollOrder遍历所有的 case 查看是否有可以立刻处理的 Channel；</li>
<li>如果存在就直接获取 case 对应的索引并返回；</li>
<li>如果不存在就会创建 runtime.sudog 结构体，将当前 Goroutine 加入到所有相关 Channel 的收发队列，并调用 runtime.gopark 挂起当前 Goroutine 等待调度器的唤醒；</li>
<li>当调度器唤醒当前 Goroutine 时就会再次按照 lockOrder 遍历所有的 case，从中查找需要被处理的 runtime.sudog 结构对应的索引；</li>
</ul>
<p>###　３.　ETCD九连问<br><a href="https://mp.weixin.qq.com/s/Ht4fsgig0DtKwjPYaLZ8zw" target="_blank" rel="external">ETCD九连问</a></p>
<p>ETCD是一个可信的分布式键值对存储服务，为分布式集群存储一些关键数据，协助分布式集群的正常运转。</p>
<ul>
<li>什么是键值数据库？ 答：一种非关系型数据库，它使用简单的键值方法来存储数据，键作为唯一标识符。</li>
<li>KV存储服务能干啥？ 答： 用存储服务为服务中介提供服务。</li>
<li>什么是服务中介？ 答：包含k-v键值对的字典，key是服务名称，value是服务提供者的地址列表。为服务提供者和服务消费者之间建立联系。</li>
<li>服务发现是什么？ 答：服务提供者、消费者和服务中介三者，实现了服务发现机制，同时etcd还提供服务注册中心的功能。通过服务发现让消费者找到服务提供者。</li>
<li>服务注册和服务发现的目的是？答：在微服务和容器化环境中，应用的增加和弹性伸缩发生频率很高，服务地址可能经常发生变化，因此需要服务注册和发现机制。<ul>
<li>服务注册：服务提供者的实例（如pod）在启动时或者位置信息发生变化时，向etcd注册自身，在停止时注销自身。如果该实例发生故障，一段时间没有发送心跳之后会被服务注册表注销；</li>
<li>服务发现：服务消费者请求服务，首先被发往一个中央路由器或负载均衡器（Service、Router等），查询服务注册表获取服务者的位置信息将请求转发给提供者。</li>
</ul>
</li>
<li>etcd作为分布式键值存储服务，必须要保证分布式系统数据的可用性和一致性。一致性算法有Paxos、Raft，其中Paxos比较复杂很多KV数据库都采用后者。ETCD也不例外。<ul>
<li>HTTP Server：用于处理用户发送的API请求以及其他ETCD节点的同步与心跳信息请求</li>
<li>Store: 用于处理ETCD支持的各类功能的事务，包括数据索引、节点状态变更、监控与反馈、时间处理与执行等</li>
<li>Raft：Raft强一致行算法的具体实现</li>
<li>WAL：Write Ahead Log，预写式日志，除了内存中存有所有数据状态以及节点索引之外，ETCD通过WAL进行持久化存储，所有数据提交前都会时间记录日志。Snapshot是为了防止数据过多而进行的状态快照，Entry表示存储的具体日志内容。</li>
</ul>
</li>
</ul>
<h3 id="4-GO-STRUCT对齐"><a href="#4-GO-STRUCT对齐" class="headerlink" title="4. GO STRUCT对齐"></a>4. GO STRUCT对齐</h3><p>合理重排字段可以减少填充，使STRUCT字段排列紧密减少空间浪费。零大小字段指struct{}通常不需要对齐，但是当作为结构体最后一个字段时需要对齐。因为如果有指针指向该字段，返回的地址将在结构体之外。如果此指针一直存活不释放对应的内存会出现内存泄露。（该内存不因结构体释放而释放）因此零大小字段要避免作为 struct 最后一个字段，防止内存浪费。</p>
<p>32 位系统上对 64 位字的原子访问要保证其是 8bytes 对齐的；当然如果不必要的话，还是用加锁（mutex）的方式更清晰简单</p>
<h2 id="一周算法汇总"><a href="#一周算法汇总" class="headerlink" title="一周算法汇总"></a>一周算法汇总</h2><h2 id="面试问题汇总"><a href="#面试问题汇总" class="headerlink" title="面试问题汇总:"></a>面试问题汇总:</h2><ol>
<li>为什么redis选择单线程模型 </li>
</ol>
<p>答： Redis从一开始选择使用单线程模型处理客户端的绝大多数网络请求，原因是：</p>
<ul>
<li>使用单线程模型可维护性高，方便开发和调试；</li>
<li>单线程模型也能并发处理客户端请求； （IO多路复用，通过select函数）</li>
<li>Redis服务中运行的绝大多数操作的性能瓶颈都不是CPU；</li>
</ul>
<p>多线程技术能够帮助我们重复利用CPU的计算资源来并发执行不同的任务，但是CPU资源往往不是Redis服务器的瓶颈。Redis如果不开启AOF备份，所有的Redis操作都会在内存中完成不涉及IO，处理非常快。</p>
<p>普通的Linux服务器上启动Redis也能处理1s 1，000,000个请求。如果这种吞吐量不满足需求，应考虑使用分片的方式将请求发送给不同的Redis来处理。</p>
<p>Redis 4.0之后的版本加入了多线程的支持，是因为新版本中加入了一些可以被其他线程异步处理的删除操作。UNLINK，FLUSHALL ASYNC，FLUSHDB ASYNC。 删除超大键值对时，几十M，几百M的数据不能在几ms时间内处理完，Redis可能会需要在释放内存空间上消耗过多时间，这些操作会阻塞待处理任务，影响Redis的PCT99和可用性。释放内存的工作由后台线程异步进行处理来提升性能。</p>
<ol>
<li>Kafka如何保证数据不丢？</li>
</ol>
<p>答： 需要分别从生产者、服务端、消费者三方面处理来保证数据不丢失。</p>
<ul>
<li><p>生产者：可以通过配置ACK策略或者retries策略保证数据不丢失：</p>
<ul>
<li>ACK=all或-1，生产者发送消息后，需要等待ISR中所有的副本都成功写入消息之后才能接收来自服务端的成功响应。即发送消息时需要leader向follow同步完数据，ISR队列中所有broker全部保存这条消息后，才向ACK发送消息。</li>
<li>对于可恢复错误（leader选举、网络抖动），配置retries&gt;0进行重试并设置重试时间间隔确保重试时可恢复错误都已恢复；对于不可恢复错误，发生异常时把消息写入DB或者本地缓存文件中，等错误修复后再把数据发送给broker端</li>
</ul>
</li>
<li>broker端：设置unclean.leader.election.enable=false，默认值为true，表示当存有最新一条记录的replication宕机时，kafka自己选举一个主节点，true表示允许未同步最新数据的replication所在节点作为主节点，数据会丢失。</li>
<li>消费端：处理好offset保证exactly-once &amp; at-least-once数据。设置enable.auto.commit=false手动提交offset，并保证offset的正确性。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/12/13/学习笔记W1/" itemprop="url">
                  学习笔记W1
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2020-12-13T22:00:00+08:00" content="2020-12-13">
              2020-12-13
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1207-1213"><a href="#1207-1213" class="headerlink" title="1207-1213"></a>1207-1213</h2><h3 id="Go知识图谱"><a href="#Go知识图谱" class="headerlink" title="Go知识图谱"></a>Go知识图谱</h3><p> <a href="https://www.processon.com/view/link/5a9ba4c8e4b0a9d22eb3bdf0#map" target="_blank" rel="external">图片链接</a></p>
<h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><p>[曹大博客] (<a href="https://mp.weixin.qq.com/s/MRZZOX7cZPIJPelcuihXUw" target="_blank" rel="external">https://mp.weixin.qq.com/s/MRZZOX7cZPIJPelcuihXUw</a>)<br>主要总结了初级程序员容易犯的代码不规范问题: </p>
<ul>
<li>命名规范: 业务内部逻辑变量命名讲究单词打全,函数名尽量能让人清晰明了其功能.</li>
<li>魔法数字: 在配置文件中集中维护特殊变量,可以引入各种方便的配置系统.可以即时修改和配置下发无需系统上下线. 如java中常用的disconf,或借助现在流行的etcd/zookeeper自己开发</li>
<li>配置文件长度: 对配置文件进行业务逻辑分类(掌握好粒度,配置文件最好有对应的comment进行检索,将系统模块拆分不同模块管理自己的配置文件)</li>
<li>函数内容长度: 根据功能进行简单的小函数划分</li>
<li>滥用回调:使用消息队列来解耦.如果系统里发生一个事件,其他模块对事件的数据有依赖,那么就让其订阅系统里产生的消息即可.(Kafka)不过可能会由于引入基于消息队列的分布式系统产生可靠性问题,saga pattern可以解决部分问题.</li>
<li>分层结果返回没有明确界限和定义: 设计模式修炼,但是要避免滥用设计模式</li>
<li>公共接口不可重入</li>
<li>访问数据库不做批量: 即使存在数据库连接池,也要尽可能批量操作提升性能</li>
<li>尽量少用if else多层嵌套</li>
<li>数据库查询使用开源builder来减少函数</li>
<li>工作流系统update前判断修改前的状态</li>
<li>考虑线程安全问题:有全局map之类的变量访问时考虑加锁</li>
<li>open资源用后关闭<h3 id="栈内存管理原理分析"><a href="#栈内存管理原理分析" class="headerlink" title="栈内存管理原理分析"></a>栈内存管理原理分析</h3><a href="https://mp.weixin.qq.com/s/1laT9M9WlLldFMYhkKxzsg" target="_blank" rel="external">链接</a><br>介绍了源码runtime/stack.go中是如何管理栈内存的</li>
</ul>
<h4 id="堆内存管理"><a href="#堆内存管理" class="headerlink" title="堆内存管理"></a>堆内存管理</h4><p>C语言申请内存通过调用malloc函数指定分配大小向操作系统直接申请,会涉及用户态和内核态的切换,导致性能下降.<br>Golang的内存管理基于tmalloc模型设计,但是局部缓存并不分配给进程/线程,而是分配给P;GC是STW,并不是每个进程单独GC.</p>
<ul>
<li>span: golang内存管理的基本单位,管理指定规格(page为单位,67种)的内存块. 最大32KB,超过32KB大小的由特殊的class表示,该classID=0.每个class只包含一个对象.</li>
<li>内存管理单元: 内存分配器器由mcache,mcentral,mheap组成<ul>
<li>mcache绑定在P上,用来给协程分配对象存储空间,不需要锁.初始化时没有任何mspan资源,使用过程中动态申请,通过双向链表连接;</li>
<li>mcentral是公共资源,会有多个mcache向它申请mspan,需要加锁.</li>
<li>mheap,当mcentral空间不足会向mheap申请新的页,也需要加锁.</li>
</ul>
</li>
<li>分配原则:<ul>
<li>tiny对象,直接向mcache的tiny对象分配器申请,空间不足时向mcache的tinySpanClass规格的span链表申请,没有继续向mcentral申请对应规格mspan,依旧没有则向mheap申请,最后都不存在向操作系统申请;</li>
<li>小对象内存分配,先向本线程mcache申请,mspan没有空闲空间-&gt;mcentral-&gt;mheap-&gt;OS page</li>
<li>大对象内存分配,直接向mheap申请spanclass=0,没有向操作系统申请</li>
</ul>
</li>
<li>GC改进: <ul>
<li>1.12版本对mheap结构添加了reclaimCredit成员变量,每次mcentral向mheap申请新的page创建span时,先扫描arenas里面的heapArena,清理GC需回收的page数量空间,由于扫描不可能刚好相等,多清理的page大小存到reclaimCredit里.下次再次扫描时先抵消这部分不够再扫描.防止mheap使用率过快增长.</li>
<li>1.12版本mheap引入scavengeCredit成员变量，当向操作系统申请内存空间的时候，会先去扫描free这个二叉树堆,span从大到小的扫描，释放所需大小的空间给os，多余释放的存储scavengeCredit中，下次再次扫描的时候会先扣除这个值。<h4 id="全局栈内存初始化"><a href="#全局栈内存初始化" class="headerlink" title="全局栈内存初始化"></a>全局栈内存初始化</h4>go程序启动时调用stackinit()初始化,涉及两个重要全局变量stackpool/stackLarge, mspanList初始化头尾为nil. <h4 id="申请内存"><a href="#申请内存" class="headerlink" title="申请内存"></a>申请内存</h4></li>
</ul>
</li>
<li>_StackMin：值为2048,表示go 代码使用最小的栈空间大小</li>
<li>stackalloc()的stacksize 是一个根据当前系统计算出来的值，win64=8kb、win32=4kb、plan9=4kb、其他系统如linux/bsd/drawin=2kb</li>
<li>从空闲池中分配栈空间，如果池为空，则向mheap申请内存，并把多余的空间缓存到池中<h4 id="栈扩容"><a href="#栈扩容" class="headerlink" title="栈扩容"></a>栈扩容</h4>linux系统下协程初始栈空间大小为仅仅只有2KB很小，仅分配了保障协程运行的最小空间。go的策略是按需申请，动态扩容，尽量减少内存浪费，每次扩容时会调用运行时方法runtime.morestack(SB) -&gt;runtime.newstack(SB) 。<h4 id="栈收缩"><a href="#栈收缩" class="headerlink" title="栈收缩"></a>栈收缩</h4>栈收缩是由gc触发执行的源码位置runtime/mgcmark.go，收缩时调用方法shrinkstack</li>
</ul>
<h3 id="深入理解StatefulSet"><a href="#深入理解StatefulSet" class="headerlink" title="深入理解StatefulSet"></a>深入理解StatefulSet</h3><p><a href="https://mp.weixin.qq.com/s/y60q0-RMh8isd4u4PuLfUg" target="_blank" rel="external">深入理解StatefulSet</a></p>
<p>StatefulSet是一种特殊的Deployment，它使用K8S里的两个标准功能Headless Service和PVC实现对拓扑状态和存储状态的维护。通过Headless Service管控每个Pod创建一个固定不变的DNS域名作为Pod在集群的网络标识。加上为Pod编号并严格按照编号顺序进行Pod调度，保证了StatefulSet对维护应用拓扑状态的支持。StatefulSet定义文件中的volumeClainTemplates声明Pod使用的PVC，它创建出来的PVC会以名称编号与Pod进行绑定，借助PVC独立于Pod的生命周期完成对应用存储状态的维护。</p>
<h3 id="分布式事务的实现原理"><a href="#分布式事务的实现原理" class="headerlink" title="分布式事务的实现原理"></a>分布式事务的实现原理</h3><p><a href="https://draveness.me/distributed-transaction-principle/" target="_blank" rel="external">分布式事务的实现原理</a></p>
<p>数据库事务拥有ACID四大特性：</p>
<ul>
<li>Atomicity  原子性</li>
<li>Consistency 一致性</li>
<li>Isolation 隔离性</li>
<li>Durability 持久性</li>
</ul>
<p>为了保证事务能在执行任意过程中回滚(原子性)并且提交的事务会永久保存在数据库中，使用事务日志来存储事务执行过程中数据库的变动，每个事务日志包含事务ID、当前被修改的元素、变动前后的值。当事务尝试对数据库进行修改时，先生成一条日志并刷新到磁盘中（append追加速度比较快），然后才会向数据库写入或更新相应的记录。</p>
<p>MYSQL中常用的存储引擎InnoDB中，事务日志有undo log、redo log两种。</p>
<p>并发执行SQL过程中可能无法保证数据库对隔离性的要求，为了避免并发带来的一致性问题、满足数据库对隔离性的要求，数据库系统往往都会使用并发控制机制来充分利用效率。常用的有：锁、时间戳、MVCC</p>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>单机中相对可靠的方法调用以及进程间通信方式没办法使用，由于网络不稳定服务之间的传递会出现障碍。分布式事务就是在不可靠的通信下实现事务的特性，分布式事务也会依赖数据库、Zookeeper、ETCD等服务追踪事务的执行过程，保证事务特性。</p>
<ul>
<li>2PC： 两阶段提交分为投票阶段和提交阶段，在投票阶段协调者向事务的参与者询问是否可以执行操作的请求，等待参与者相应。参与者执行相应的事务操作并记录重做和回滚日志，所有执行成功的参与者向协调者发送AGGREMENT/ABORT表示执行操作结果。协调者根据投票结果向参与者发送提交或回滚指令。两阶段提交是一种阻塞协议，如果事务执行过程中协调者宕机，事务的一部分参与者将永远无法完成事务，可能出现参与者状态不一致的问题。</li>
<li>3PC：为了解决上述问题，引入超时机制和准备阶段。如果协调者或者参与者在规定时间内没有接收到来自其他节点的响应根据当前的状态选择提交或终止整个事务。当参与者向协调者发送 ACK 后，如果长时间没有得到协调者的响应，在默认情况下，参与者会自动将超时的事务进行提交，不会像两阶段提交中被阻塞住；</li>
</ul>
<p>MySQL 的 InnoDB 引擎其实能够支持分布式事务，即 XA 事务；XA 事务就是用了2PC实现分布式事务，其中事务管理器为协调者，而资源管理器就是分布式事务的参与者。XA 确实能够保证较强的一致性，但是在 MySQL XA 的执行过程中会对相应的资源加锁，阻塞其他事务对该资源的访问，如果事务长时间没有 COMMIT 或者 ROLLBACK，其实会对数据库造成比较严重的影响。</p>
<h4 id="Saga"><a href="#Saga" class="headerlink" title="Saga"></a>Saga</h4><p>两阶段提交其实可以保证事务的强一致性，但是在很多业务场景下，我们其实只需要保证业务的最终一致性，在一定的时间窗口内，多个系统中的数据不一致是可以接受的，在过了时间窗口之后，所有系统都会返回一致的结果。放弃满足ACID，选择实现 BASE(Basic Availability, Soft, Eventual consistency) 事务。</p>
<p>Saga 其实就一种简化的分布式事务解决方案，它将一系列的分布式操作转化成了一系列的本地事务，在每一个本地事务中我们都会更新数据库并且向集群中的其他服务发送一条的新的消息来触发下一个本地的事务；一旦本地的事务因为违反了业务逻辑而失败，那么就会立刻触发一系列的回滚操作来撤回之前本地事务造成的副作用。</p>
<p>Sagas解决长事务问题。</p>
<h3 id="一周算法汇总"><a href="#一周算法汇总" class="headerlink" title="一周算法汇总"></a>一周算法汇总</h3><p><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="external">lc55_jump-game_Medium</a><br><a href="https://github.com/xiaozhazi/leetcode_go/blob/master/lc55_jumpgame.go" target="_blank" rel="external">实现</a></p>
<p><a href>lc51_nqueen_Hard</a><br><a href="https://github.com/xiaozhazi/leetcode_go/blob/master/lc51_nqueen.go" target="_blank" rel="external">实现</a></p>
<p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="external">lc322_coin-change_Medium</a><br><a href="https://github.com/xiaozhazi/leetcode_go/blob/master/lc322_coinchange.go" target="_blank" rel="external">实现</a><br><a href="https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/" target="_blank" rel="external">lc862_shortest-subarray-with-sum-at-least-k_Hard</a><br><a href="https://github.com/xiaozhazi/leetcode_go/blob/master/lc862_subarraywithsumatleastk.go" target="_blank" rel="external">实现</a></p>
<p><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="external">lc198_house-robber_Easy</a><br><a href="https://github.com/xiaozhazi/leetcode_go/blob/master/lc198_houserobber.go" target="_blank" rel="external">实现</a><br><a href="https://leetcode-cn.com/problems/fancy-sequence" target="_blank" rel="external">lc1622_fancy-sequence_Hard</a><br><a href="https://github.com/xiaozhazi/leetcode_go/blob/master/lc1622_fancysequence.go" target="_blank" rel="external">实现</a></p>
<h3 id="面试问题汇总"><a href="#面试问题汇总" class="headerlink" title="面试问题汇总:"></a>面试问题汇总:</h3><ol>
<li><p>new 和 make的区别<br>答:<br>参考这篇文章<a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-make-and-new/" target="_blank" rel="external">Go语言中的make和new</a><br>make是初始化内置的数据结构,如切片,哈希表,channel;<br>在编译期间的类型检查阶段,GO语言将代表make关键字的OMAKE节点根据参数类型不同转换为OMAKESLICE,OMAKEMAP,OMAKECHAN三种节点,这些节点调用不同的运行时函数来初始化相应数据结构.</p>
<ul>
<li>slice := make([]int, 0, 100)</li>
<li>hash := make(map[int]bool, 10)</li>
<li>channel := make(chan int, 5)<br>new的作用是根据传入的类型分配一片内存空间,并返回这片内存空间的指针.<br>对于new关键字编译器会在中间代码生成阶段先转换为ONEWOBJ类型的阶段,然后根据申请内存空间大小:0返回表示空指针的zerobase变量,反之转换成runtime.newobject函数在堆上申请内存.<br>其中runtime.newobject函数会是获取传入类型占用空间的大小,调用runtime.malloc并返回指向这片内存的指针</li>
<li>i := new(int) </li>
<li>var v int | i := &amp;v</li>
</ul>
</li>
<li><p>go 引用类型有哪些<br>答：<br>值类型有int，float， bool， string， 数组， struct<br>引用类型有 指针，slice切片，map，channel，函数等<br>两者的区别是，值类型变量直接存储值，内存通常在栈中分配；引用类型变量通常存储的是一个地址，这个地址对应的内存空间存储真正的数值，内存通常在堆中分配。</p>
</li>
<li><p>go的内存模型中，为什么小对象多了会造成gc压力<br>答： 小对象过多会导致GC三色法消耗过多的GPU</p>
</li>
<li><p>将10阶对称矩阵压缩存储到一维数组A中，则数组A的长度最少为 10*10/2</p>
</li>
<li><p>golang中selct的多个case同时成立时，选择的是哪一个？<br>答： select在遇到多个Channel同时响应时会随机挑选case执行， 这个设计是十多年前select提交引入并一直保留到现在的。如果多个条件满足时我们按顺序执行，那么后面的条件将会得不到执行，随机的引入是为了避免饥饿问题的发生。</p>
</li>
<li><p>golang 中除了使用 sync 锁，还可以如何保证并发安全? atomic 是什么？<br>答： golang的auomic院子操作是所有锁机制中效率最高的，能够使用原子操作的地方尽量使用。</p>
</li>
<li><p>sync.Map 对键的类型有什么要求么？<br>答： go语言规定键类型的值之间必须支持==和！=操作符判断，而函数类型，字典类型，切片类型不支持判等操作，因此键类型不能是上述几种类型。</p>
</li>
<li><p>如何避免死锁? golang 中如何检测死锁?<br>答： </p>
</li>
<li><p>不使用 goroutine 怎么实现监听三个 channel，合并三个 channel，变成一个新的 channel，这三个任意有消息的时候都要给 新 channel 传递，都没消息的时候要关闭那个新的 channel？</p>
<p> func merge(ins …&lt;-chan string) &lt;- chan string {<br>   var wg sync.WaitGroup<br>   out := make(chan string)</p>
<p>   p := func (in &lt;-chan string) {</p>
<pre><code>defer wg.Done()
for c := range in {
  out &lt;-c
}
</code></pre><p>   }<br> }</p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/11/14/深入理解计算机系统第8周/" itemprop="url">
                  《深入理解计算机系统》第8周
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2020-11-14T22:00:00+08:00" content="2020-11-14">
              2020-11-14
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>虚拟内存是现代系统提供的一种对主存的抽象概念，它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域按需在磁盘和主存之间来回传送数据；为每个进程提供了一致的地址空间，简化了内存管理；并且保护每个进程的地址空间不被其他进程破坏。通过本章学习可以了解虚拟内存是如何工作的，以及如何在程序中使用和管理虚拟内存，避免一些和内存有关的错误出现。<br>现代系统通过内存映射将虚拟内存和磁盘文件关联，为共享数据、创建新进程以及加载程序提供了一种高效的机制。应用可以使用mmap函数来手工地创建和删除虚拟地址空间的区域。对于运行时才知道大小的数据结构，大多数程序通过动态内存分配器管理虚拟地址空间中的堆区域，并且显式或自动地释放内存。</p>
<ul>
<li>早期的PC通过物理寻址，现代处理器多采用虚拟寻址来访问主存，虚拟地址在被送到内存之前通过MMU地址翻译转换为物理地址。</li>
<li>虚拟页，VM将虚拟内存分割为大小固定的块，虚拟页有以下三种：<ul>
<li>未分配的，没有任何数据与之关联，不占用任何磁盘空间；</li>
<li>缓存的，当前已缓存在物理内存中的已分配页；</li>
<li>未缓存的，未缓存在物理内存中的已分配页</li>
</ul>
</li>
<li>DRAM缓存表示虚拟内存系统的缓存，是全相联的，因为虚拟页通常为4K-2M，不命中时替换开销较大，因此替换策略非常重要。因为对磁盘访问时间长，DRAM缓存总是使用写回而非直写。</li>
<li>局部性原则保证了任意时刻，程序将趋向于在一个较小的active page集合上工作，即常驻集合/工作集。如果工作集的大小超出了物理内存大小，程序将产生一种不幸的状态，即抖动。页面将不断地换进换出。</li>
<li>将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称为内存映射，Linux系统提供一个成为mmap的系统调用，允许应用程序自己做内存映射。     </li>
<li>正常命中时CPU硬件执行步骤：<ul>
<li>处理器生成一个虚拟地址并传送给MMU；</li>
<li>MMU生成PTE地址，从高速缓存/主存请求得到它；</li>
<li>高速缓存/主存向MMU返回PTE；</li>
<li>MMU构造物理地址，并把它传送给高速缓存/主存；</li>
<li>高速缓存/主存返回所请求的数据字给处理器</li>
</ul>
</li>
<li>当缺页时，需要硬件和操作系统内核写作完成：<ul>
<li>前三步相同</li>
<li>PTE有效位为0，MMU触发异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序；</li>
<li>缺页处理程序确定出物理内存中的牺牲页，如果该页已经被修改，则把它换出到磁盘；</li>
<li>缺页处理程序页面调入新的页面，并更新内存中的PTE</li>
<li>缺页处理程序返回到原来的进程，再次执行导致缺页的指令。主存将请求字返回给CPU。</li>
</ul>
</li>
<li>频繁读取PTE会使得内存多取一次数据，为了消除开销，现代系统利用TLB（MMU中一个PTE的小缓存）</li>
<li>如果每个进程都在物理内存中保存常用代码的副本会比较浪费，内存映射提供了一种机制控制多个进程共享对象。一个对象可以被映射到虚拟内存的一个区域，作为共享对象或者私有对象。对于共享对象，进程对该区域的任何写操作，其他把该对象映射到虚拟内存的进程也可见。私有对象使用写时复制的技术被映射到虚拟内存中，延迟私有对象中的副本到最后可能的时刻来充分利用物理内存。</li>
<li>Fork调用时，内核为新进程创建虚拟内存，创建了当前进程的mm_struct、区域结构和页表的原样副本，将两个进程的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。当fork在新进程中返回后，新进程现在的虚拟内存刚好和调用fork时存在的虚拟内存相同。当两个进程中的任何一个后来进行写操作时，写时复制都会创建新页面，即为每个进程保持了私有地址空间的抽象概念。</li>
<li>程序使用动态内存分配的最重要原因是直到程序实际运行时才知道某些数据结构的大小，数据大小的最大值可以由可用的虚拟内存数量来限制。</li>
<li>管理和使用虚拟内存中常见的错误类型：间接引用坏指针，读取未初始化的内存、允许栈缓冲区溢出、假设指针和它们指向的对象大小相同，引用指针而不是它指向的对象、误解指针运算、引用不存在的变量、以及引起内存泄漏等。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/11/06/深入理解计算机系统第7周/" itemprop="url">
                  《深入理解计算机系统》第7周
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2020-11-06T22:00:00+08:00" content="2020-11-06">
              2020-11-06
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本周主要学习了异常控制流ECF（Exception Control Flow）相关知识，它可以发生在计算机系统的各个层次，是操作系统用来实现I/O、进程和虚拟内存的基本机制。应用程序通过ECF和操作系统进行交互，如磁盘写数据、网络读取数据、创建新进程、终止当前进程等。理解ECF可以帮助我们编写有趣的应用程序并且更好得理解并发。C++/Java语言提供的异常处理机制，允许程序运行非本地跳转来相应错误，这些都是ECF的一种应用层形式。</p>
<ul>
<li><p>异常是控制流中的突变，用来响应处理器状态中的某些变化。在任何情况下，处理器检测到有事件发生时，它会通过异常表来进行间接过程调用，到异常处理程序来处理。完成处理后根据异常类型有以下3种情况：</p>
<ul>
<li>处理程序将控制返回给当前指令；</li>
<li>处理程序将控制返回给下一条指令并执行；</li>
<li>处理程序终止被中断的程序</li>
</ul>
</li>
<li><p>异常和过程调用的区别：</p>
<ul>
<li>过程调用时，在跳转前处理器将返回地址压栈。异常处理时根据异常的类型返回地址要么是当前指令要么是下一条指令；</li>
<li>处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。如X86-64会压入包含当前条件码的EFLAGS寄存器</li>
<li>如果控制从用户程序转移到内核，则压入内核栈中</li>
<li>异常处理程序运行在内核模式下</li>
</ul>
</li>
<li><p>异常类型： <strong>中断interrupt、陷阱trap、故障fault、终止abort</strong></p>
<ul>
<li>中断： 来自I/O设备的信号/异步/总是返回到下一条指令</li>
<li>陷阱：有意的异常/同步/总是返回到下一条指令 （用途： 在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用）</li>
<li>故障：潜在的可恢复的错误/同步/可能返回当前指令 （如缺页异常）</li>
<li>终止：不可恢复的错误/同步/不会返回</li>
</ul>
</li>
<li><p><strong>上下文切换</strong>是内核使用的一种较高层形式的异常控制流，用来实现多任务。</p>
</li>
<li>父进程通过<strong>fork函数</strong>创建子进程，子进程得到与父进程用户级虚拟地址空间相同的一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程打开文件描述符相同的副本，可以读写父进程中打开的任何文件。两者最大的区别在于不同的PID。 fork函数被父进程调用一次，返回两次—- 一次是返回到父进程，一次返回到新创建的子进程。在父进程中fork返回子进程的PID；在子进程中fork返回0.</li>
<li>Linux信号是一种更高层的软件形式的异常，允许进程和内核中断其他进程。一个发出来没有被接收的信号叫做待处理信号，在任何时刻一种类型至多只会有一个待处理信号。（后续发送的不会排队等待，被简单丢弃）</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/10/25/深入理解计算机系统第5周/" itemprop="url">
                  《深入理解计算机系统》第5周
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2020-10-25T22:00:00+08:00" content="2020-10-25">
              2020-10-25
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>作为开发者需要理解存储器层次结构，以及了解系统是如何将数据在存储器层次结构中移动，这样在编写程序时可以利用这些特性来提升性能。其中最主要的就是局部性原理，具有良好局部性的程序会更倾向于从较高层次访问数据，减少CPU访问时间。</p>
<ul>
<li>将注意力集中在内循环上，大部分计算和内存访问都发生在这里；</li>
<li>通过按照数据对象存储在内存中的顺序，以步长为1的来读取数据，使得程序空间局部性最大；</li>
<li>一旦从存储器中读入了一个数据对象，就尽可能多地使用它，从而使得程序中的时间局部性最大；</li>
</ul>
<p>这一章我是结合和CMU的课程视频来学习的，相比前几章来说，在看书之前已经了解了哪些重点概念需要关注，个人感觉效果还不错。</p>
<p>首先从基本的存储技术学习：</p>
<p><strong>RAM 随机访问存储器：</strong></p>
<ul>
<li><strong>SRAM，</strong>静态随机访问存储器，常用来做高速缓存，可以在CPU芯片上也可以在片下。将每个位都存储在一个双稳态存储器单元里，每个单元由一个六晶体管电路实现。只要有电就会永远保持它的值，即使有干扰来扰乱电压，消除后也会立即恢复到稳定值。</li>
<li><strong>DRAM，</strong>动态随机访问存储器，常用来作为主存以及图形系统的帧缓冲。每个位存储为对一个电容的充电，对干扰非常敏感，当电容的电压被扰乱后就永远不会恢复了。<ul>
<li>两者相比，只要供电SRAM就会保持不变，与DRAM不同，不需要刷新。SRAM的存取也比DRAM快得多，但是SRAM比DRAM单元使用更多的晶体管，因此密集度低，更贵且功耗更大。<br>传统DRAM，二维阵列，读取时先RAS（Row Access Strobe）请求再CAS（Column Access Strobe）请求。</li>
</ul>
</li>
<li><strong>内存模块，</strong>DRAM芯片封装在内存模块中，插入主板的扩展槽，以64位为块传送数据到呢欧村控制器和从内存控制器传出数据。</li>
<li><strong>增强的DRAM：</strong><ul>
<li>快页模式，允许对同一行连续地访问可以直接从行缓冲区得到服务。</li>
<li>扩展数据输出DRAM，允许各个CAS信号在时间上靠得更紧密一些。</li>
<li>同步DRAM，能够比一部的存储器更快输出单元内容。</li>
<li>双倍数据速率同步DRAM，常见的DDR2 DDR4 DDR8等</li>
<li>视频RAM，用在图形系统的帧缓冲区中。<ul>
<li>1）VRAM输出是通过依次对内部缓冲区的整个内容移位得到；</li>
<li>2）VRAM允许对内存并行读写。</li>
</ul>
</li>
</ul>
</li>
<li><strong>非易失性存储器，</strong> 断电后依然能保存数据。 ROM, PROM, EPROM,flash memory等<br>访问主存，通过总线的共享电子电路在处理器和DRAM主存之间传递数据。</li>
</ul>
<p><strong>磁盘存储器：</strong>从磁盘上读取数据时间为ms级，比DRAM慢10万倍，比SRAM慢100万倍。<br>磁盘的构造相关内容CMU的课程视频上讲解的比较清晰，所以看书时主要关注在于磁盘的访问。</p>
<p>CPU通过内存映射I/O技术来发送命令，磁盘接受到命令后，将逻辑块号翻译成扇区地址，读取该扇区内容。然后将内容直接传到主存，不需要CPU的干涉，即DMA传送。当传送完成后，磁盘控制器通过给CPU发送一个中断信号来通知。</p>
<p><strong>SSD固态硬盘，</strong>由半导体存储器构成，没有移动的部件，因而随意访问时间比旋转磁盘快，能耗更低且结实。不过缺点是反复写后，闪存块会磨损，通过平均磨损逻辑来将擦除平均到所有块上来最大化每块的寿命。</p>
<p><strong>然后是局部性原理：</strong>空间局部性和时间局部性。现代计算机系统各个层次都有利用到局部性原理，如高速缓存等（CPU芯片、操作系统、分布式文件系统和万维网中都使用了缓存）。</p>
<p><strong>最后是高速缓存相关，</strong>其结构可以用四元组（S,E,B,m）来描述，容量大小C=SEB。其结构使得它能够通过简单地检查地址位，找到请求字（类似哈希表）。1）组选择；2）行匹配；3）字抽取。 </p>
<p>按照类型可以分为<strong>直接映射高速缓存、组相联高速缓存、全相联高速缓存</strong>。</p>
<p>需要注意的是，即使程序具备良好的空间局部性，高速缓存中也有足够的空间存放块，但是还可能因为映射到相同组产生抖动现象，即高速缓存反复地加载和驱逐相同的高速缓存块的组。 此时可以通过数据填充将其映射到不同的组来消除<strong>抖动冲突不命中</strong>。</p>
<p>高速缓存写操作：</p>
<ul>
<li>命中时，向更低一层写时分为两种：<strong>直写和写回</strong>。直写简单但是每次写都会引起总线流量；写回尽可能推迟更新，只有当替换算法驱逐该块时才写，由于局部性显著减少总线流量，但增加了复杂性。</li>
<li>不命中时，有<strong>写分配和非写分配</strong>两种。写分配需要加载相应第一层的块到高速缓存中，然后更新，试图利用局部性原理。非写分配避开高速缓存，直接把这个字写入到下一层。直写高速缓存通常是非写分配的，写回高速缓存是写分配的。</li>
</ul>
<p>对开发者来说，在设计程序时可以心里默认采用使用写回合写分配的高速缓存模型，在高层次开发程序展示良好的空间和时间局部性。原因：</p>
<ul>
<li>通常较长的传送时间，存储器层次结构中较低的缓存更可能使用写回；</li>
<li>逻辑电路密度提高，写回的高复杂性也越来越不成阻碍；</li>
<li>写回写分配试图利用局部性，和处理读的方式对称；</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/10/18/深入理解计算机系统第4周/" itemprop="url">
                  《深入理解计算机系统》第4周
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2020-10-18T22:00:00+08:00" content="2020-10-18">
              2020-10-18
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上周第三章已经看完，因此这周选择了加看第五章优化程序性能，通常编译器可以代替我们进行程序优化，例如循环展开、代码移动等。但是由于函数存在编译器无法感知的副作用，往往还需要程序员在编写代码时注重效率。</p>
<p>一些看上去无足轻重的代码段可能隐藏着<strong>渐进低效率</strong>（asymptotic inefficiency），在数据量小时测试可能无法发现问题，但部署环境后代码会突然成为瓶颈。有经验的程序员工作的一部分就是避免引入这样的渐进低效率。</p>
<p>比如在循环中止条件我们经常会用到 strlen（s）来作为循环中止条件，而strlen所需时间和字符串长度N成正比，如果每次循环迭代前都判断一次，那么循环的整体运行时间会是N<em>N。此时我们如果将字符串长度提前进行计算，再进行循环判断就会显著提升性能。书中实现对1048576字符进行测试，循环运行时间从17分钟降低到2毫秒， <em>*50W倍左右的提升</em></em>。</p>
<p>当前GCC版本会对整数运算执行重新结合，但不是总有好的效果，通常循环展开和并行地累计在多个值中是提高程序性能的更可靠的方法。</p>
<p><strong>CPE Cycles Per Element</strong>，作为一种表示程序性能并指导我们改进代码的度量标准。可以帮助我们在更细节的级别上理解迭代程序的循环性能。</p>
<p>未经优化的代码通常效率比较低，简单地使用命令行选项就能显著地提高程序性能（超过两个数量级）。</p>
<p><strong>代码移动，</strong>识别要执行多次（如循环内）但是计算结果不会改变的计算，将其移动到代码前不会多次求值的部分来提高性能。优化编译器会尝试进行代码移动，但是不能可靠地发现一个函数是否会有副作用。因此为了改进代码，程序员必须经常帮助编译器显示地完成代码移动。</p>
<p><strong>过程调用会带来开销，而且妨碍大多数形式的程序优化。</strong></p>
<p><strong>尽量消除代码中不必要的内存读写，用寄存器来保存中间值来提升性能</strong></p>
<p>要进一步提高性能，必须<strong>考虑利用处理器微体系结构的优化</strong>，也就是处理器用来执行指令的底层系统设计。要想充分提高性能，需要仔细分析程序，同时代码的生成也要针对目标处理器进行调整。</p>
<p><strong>延迟界限（latency bound）</strong>，在下一条指令开始之前，这条指令必须结束。当代码中的数据相关限制了处理器利用指令级并行的能力时，延迟界限能够限制程序性能。</p>
<p><strong>吞吐量界限（throughput bound）</strong>，刻画了处理器功能单元的计算能力，这个界限是程序性能的终极限制。</p>
<p><strong>整体操作：</strong> </p>
<ul>
<li>ICU从高速缓存中读取指令，通常会在当前正在执行的指令很早之前取指，才有足够的时间对指令进行译码并把操作发送给EU。</li>
<li>当程序遇到分支时，通过分支预测猜测是否会执行分支，并且同时预测分支的目标地址。</li>
<li>使用投机执行的技术，取出位于它预测的分支会调到的地方的指令，对指令进行译码，甚至在确定分支预测正确之前开始执行。</li>
<li>如果分支预测错误的话，会将状态重新置于分支点的状态，接着往下执行。</li>
</ul>
<p><strong>功能单元的性能：由延迟、时间、容量来刻画。</strong></p>
<ul>
<li><strong>延迟</strong>latency，表示完成运算所需要的总时间；</li>
<li><strong>发射时间</strong>issue time表示两个连续的同类型运算之间需要的最小时钟周期数；</li>
<li><strong>capacity</strong>表示能够执行该运算功能单元的个数。 其中除法不是完全流水线化的，发射时间=延迟 即在开始一条新运算之前，除法器必须完成整个除法，使得其成为一个相对开销很大的运算。</li>
</ul>
<p><strong>循环展开</strong>通过增加每次迭代计算的元素数量，减少循环的迭代次数。编译器可以很容易地执行循环展开，只要优化级别设置得足够高。GCC -O3就会执行。</p>
<p><strong>提高并行性：</strong></p>
<p>对于可结合和可交换的合并运算来说，通过将一组合并运算分割成两路或多路，最后再合并来提高性能。</p>
<p>重新结合变换打破顺序相关从而使性能提高到延迟界限之外的方法，减少计算中关键路径上操作的数量，更好地利用功能单元的流水线能力。 （大多数编译器不会对浮点运算重新结合，因为这些运算是不保证结合的）</p>
<p><strong>其他一些制约程序在实际机器上性能的因素</strong>：</p>
<ul>
<li><strong>寄存器溢出</strong>，并行度p超过了可用的寄存器数量，编译器会溢出，将某些临时值存放在内存中。此时再进行循环展开就没有效果，甚至会导致性能变差。</li>
<li><strong>分支预测错误处罚</strong>, 大约19个时钟周期，赌注很高。因此注意以下通用原则：<ul>
<li>不要过分关心可预测的分支；</li>
<li>书写适合条件传送实现的代码</li>
</ul>
</li>
</ul>
<p>总结来说，优化程序性能的基本策略如下：</p>
<ul>
<li><strong>高级设计：</strong> 选取合适的算法和数据结构，避免使用那些会产生渐进低效率的算法OR编码技术；</li>
<li><strong>基本编码原则</strong>：避免限制优化的因素，使编译器产生高效地代码。</li>
<li><strong>消除连续的函数调用</strong>：代码移动；</li>
<li><strong>消除不必要的内存引用</strong>： 引入临时变量；</li>
<li><strong>低级优化</strong>： 结构化代码以利用硬件功能；<ul>
<li>循环展开</li>
<li>累积变量、重新结合等技术，提高指令级并行</li>
<li>功能性的风格重写条件操作，使得编译器采用条件数据传送。</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/10/11/深入理解计算机系统第3周/" itemprop="url">
                  《深入理解计算机系统》第3周
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2020-10-11T22:00:00+08:00" content="2020-10-11">
              2020-10-11
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第三章主要是从汇编代码级来了解程序是如何运行，通过阅读汇编代码一方面可以理解编译器的优化能力帮助分析优化源码，另一方面可以了解程序存储运行控制信息的细节可以用来防御代码漏洞等。</p>
<p>有一定的汇编基础，所以这章比上章读起来稍微轻松一些，长假期间闲时顺手翻完。</p>
<p>主要记录了以下几个知识点：</p>
<p><strong>首先是定义</strong></p>
<ul>
<li>PC,存储将要执行的下一条指令在内存中的地址</li>
<li>整数寄存器，存储整数数据和指针，有的jicunq被用来记录某些重要的程序状态</li>
<li>条件码，保存最近执行的算术或逻辑指令的状态信息，用来实现控制或数据流中的条件变化</li>
<li>向量寄存器用来存放一个或多个整数或浮点数值。</li>
<li>一个X86-64的CPU中包含一组16个64位通用目的寄存器，用来存储整数数据和指针。其中%rsp是栈指针用来指明运行时栈的结束位置。</li>
</ul>
<p>数据传输指令、入栈出栈数据指令、算术逻辑操作以及跳转指令之前都有一定的了解，这次补充了下乘法和除法的运算逻辑。</p>
<p>2个64位有符号/无符号整数相乘需要128位来表示，X86-64对128位数的操作提供有限的支持。</p>
<p>mulq（无符号数乘法）和imulq（补码乘法）都要求一个参数必须在寄存器%rax中，另一个作为指令的源操作数给出，乘积存放在寄存器%rdx（高64位）和%rax（低64位）中。</p>
<p>除法或取模运算，由单操作数除法指令来提供，idivl将寄存器%rdx（高64位）和%rax（低64位）中的128位数作为被除数，除数作为指令操作数给出，将商存储在%rax中，余数存储在%rdx中。</p>
<p>条件码通常不会直接读取，常用的三种方法：</p>
<ul>
<li>根据条件码的某种组合将一个字节设置为0/1； </li>
<li>条件跳转到程序的其他部分；</li>
<li>有条件地传送数据。 常用的条件码寄存器：<ul>
<li>CF：进位标志，可用来检查无符号操作的溢出</li>
<li>ZF：零标志位</li>
<li>SF：符号标志</li>
<li>OF：溢出标志，最近的操作导致一个补码溢出</li>
</ul>
</li>
</ul>
<p><strong>基于条件数据传送的代码会比基于条件控制转移的代码性能要好</strong>是因为：</p>
<p>首先，现代处理器通过pipelining重叠连续指令的步骤来获取高性能。</p>
<p>当机器遇到条件跳转指令时只有当分支条件求值完成后才能决定分支往哪走，分支预测逻辑可靠的情况下流水线中依旧会充满指令并行，但是当跳转错误预测时需要丢掉它为跳转指令后续所有指令已做的工作，浪费大约15-30个时钟周期，导致程序性能严重下降。</p>
<p>同条件跳转不同，处理器不需要预测结果就可以执行条件传送，处理器只是读源值，检查条件码，然后要么更新目的寄存器要么保持不变。</p>
<p>不过条件传送也不总是会提高代码效率，需要权衡复杂计算开销和分支预测错误开销来判断具体使用哪种。</p>
<p><strong>过程</strong>是软件中的一种重要抽象，要提供对过程的机器级支持需要处理<strong>传递控制、传递数据、分配和释放内存</strong>等机制。</p>
<p>C语言过程调用机制的一个关键特性在于使用了栈数据结构的后进先出的内存管理原则，每个过程在栈中都有自己的私有空间，多个未完成调用的局部变量不会相互影响。</p>
<p>C语言对数据引用不进行任何边界检查，局部变量和状态信息都存放在栈中。这两种情况结合在一起，对越界的数组元素写操作会破坏存储在栈中的状态信息，即常见的<strong>缓冲区溢出问题</strong>。 </p>
<p>这种问题可以被用来攻击系统安全，将攻击代码包含在输入字符串中或者将一个指向攻击代码地址的指针覆盖返回地址等。</p>
<p>现代的编译器和操作系统实现了很多机制限制入侵者通过缓冲区溢出攻击获得系统控制。常见的机制：</p>
<ul>
<li>栈随机化：为了插入攻击代码，攻击者既要插入代码又要插入指向该代码的指针。这个指针也是攻击字符串的一部分，要产生这个指针需要知道字符串存放的栈地址。栈的位置在程序每次运行时都有变化使得改地址难以预测。在Linux中栈随机化已经成为标准行为，ASLR地址空间布局随机化。</li>
<li>栈破坏检测：第二道防线是能够检测到何时栈被破坏，栈保护者机制通过canary金丝雀值是否被改变来判断，该值是程序每次运行随机产生的，如果被某个函数或操作改变那么异常中止该程序。</li>
<li>限制可执行代码区域：消除攻击者向系统中插入可执行代码的能力。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/09/27/深入理解计算机系统第2周/" itemprop="url">
                  《深入理解计算机系统》第2周
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2020-09-27T22:00:00+08:00" content="2020-09-27">
              2020-09-27
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本周主要学习第二章信息的表示和处理,数值处理部分相对比较枯燥.第一遍看到后面定理晕头转向的,后面看第二遍的时候将所有练习题都跟着动手完成,效果明显好了很多.</p>
<p>对于整数运算,表示数字的有限字长限制了可能值的取值范围,结果存在溢出可能.C语言中强制类型转换等一些规定可能会产生非直观的结果,需要注意.</p>
<p>浮点数计算只有有限的范围和精度,并且不遵守普遍的算数属性.</p>
<p>重新温顾的知识点:</p>
<p> <strong>大端/小端法</strong></p>
<p>最低有效字节在前面的是小端法,最高有效字节在最前面的是大端法. (大多数Intel兼容机都只用小端法)</p>
<p>假设变量x=0x01234567在地址0x100处</p>
<pre><code> |0x100 0x101 0x102 0x103|
大端 |01 | 23 | 45 | 67 |
小端 |67 | 45 | 23 | 01 |
</code></pre><ul>
<li>网络传输二进制数据时通过网络标准转换来避免不同机器字节顺序的影响.</li>
<li>反汇编代码阅读时需要考虑字节顺序.</li>
<li>C语言中强制类型转换/Union允许一种数据类型引用一个对象时需要考虑字节顺序.</li>
</ul>
<p><strong>有符号数和无符号数之间的转换</strong></p>
<p>补码转换为无符号数时</p>
<pre><code>T2U(x)=x (x&gt;=0); T2U(x)=x+2^w(x&lt;0,w位)
</code></pre><p>无符号数转换为补码时<br>    U2T(u)=u (u&lt;=TMax); U2T(u)=u-2^w(u&gt;=TMax)</p>
<p>C语言中对同时包含有符号和无符号数的表达式处理时,会隐式的将有符号数强制转换为无符号数,对于标准运算符并无差异,但是遇到关系运算符时会导致问题.</p>
<pre><code>如 -1 &lt; 0U, 会先将-1转换为4294967295U 导致非直观结果出现.
</code></pre><p><strong>扩充整数字长时, 补码数符号扩展,无符号数零位扩展.</strong></p>
<p><strong>无符号整数加法</strong> </p>
<pre><code>x+y=x+y(正常) x+y=x+y-2^w (溢出时)
</code></pre><p><strong>补码加法</strong></p>
<pre><code>x+y=x+y-2^w(正溢出), x+y=x+y(正常), x+y=x+y+2^w(负溢出)
</code></pre><p><strong>无符号数乘法</strong> </p>
<pre><code>xy=(xy) mod 2^w
</code></pre><p><strong>补码乘法</strong></p>
<pre><code>xy=U2T((xy) mod 2^w)
</code></pre><p><strong>浮点数</strong></p>
<p>通过将数字编码为x*2^y的形式来近似地表示实数,最常见的浮点精度都float和double.</p>
<p>IEEE浮点通过符号s/尾数M/阶码E来表示,32位1+8+23,64位1+11+52,被编码的值有三种不同的情况:</p>
<ul>
<li>规格化的值, 阶码不全为0也不全为1</li>
<li>非规格化的值,阶码域全为0</li>
<li>特殊值, 阶码域全为1,小数域全为0时(正无穷,负无穷); 阶码域全为1,小数域非零(NaN)</li>
</ul>
<p><strong>四种舍入方式</strong>中默认的是Round-to-even,将数字向上或向下舍入使得结果的最低有效数字是偶数.(可以避免统计偏差)</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/09/20/深入理解计算机系统第1周/" itemprop="url">
                  《深入理解计算机系统》第1周
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2020-09-20T22:00:00+08:00" content="2020-09-20">
              2020-09-20
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第一章主要是以helloworld程序为切入点对计算机系统整体进行阐述，硬件和软件如何通过协同操作来运行应用程序。对于编译链接的流程和基本概念比较熟悉所以本章主要记录以下两点笔记：</p>
<p><strong>Amdahl定律：</strong></p>
<p>当对系统的某个部分进行加速时，整体性能的影响取决于该部分的重要性和加速程序。该定律主要用于并行计算领域预测多个处理器时的理论最大加速比，实际场景中程序往往并不能有效的利用多核，因为系统中不可避免的会存在一些需要串行访问的资源。因此在多核处理器中还要考虑如何降低串行计算部分的比例以及降低交互开销。</p>
<p><strong>Concurrency和parallelism：</strong></p>
<p><strong>线程级并发：</strong><br>单处理器系统中并发是通过进程执行切换来模拟出并发的效果，允许多用户同时与系统交互。随着多核处理器的出现减少了执行多个任务时模拟并发的需要，但是要求程序以多线程方式进行编写来高效地并行执行。</p>
<p>另外，超线程允许一个CPU执行多个控制流的技术，常规的处理器大约需要2w个时钟周期做线程切换，超线程处理器可以在单个周期的基础上决定执行哪个线程（FMT，通过拉长每个线程的平均执行时间来实现随时切换，英伟达和AMD的GPU中用的比较多）。现实中绝大多数程序并不会占用CPU的所有资源，超线程的引入主要就是为了更好得利用空闲资源。</p>
<p><strong>指令级并行：</strong></p>
<p>每条指令从开始到结束大约需要20+个时钟周期，但是处理器通过流水线技术，将指令划分为不同的阶段通过并行操作能够达到每个时钟周期2-4个指令的执行速率。</p>
<p><strong>单指令多标量并行SIMD：</strong></p>
<p>通过特殊的硬件来支持一条指令产生多个可以并行的操作。</p>
<p>这些应该都是本科学习过的知识点，重新温习了一遍。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/08/15/设计模式之美第二周/" itemprop="url">
                  设计模式之美第二周
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2020-08-15T23:24:00+08:00" content="2020-08-15">
              2020-08-15
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？"><a href="#理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？" class="headerlink" title="理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？"></a>理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？</h2><p>本文主要针对四大特性，结合实际代码，帮助我们了解每个特性存在的意义和目的，以及它们能解决哪些编程问题。</p>
<h3 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装 Encapsulation"></a>封装 Encapsulation</h3><p>封装也叫作信息藏匿或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或数据。</p>
<p>对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持。这个语法机制就是访问权限控制。</p>
<p>如果对类中属性访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更灵活，但是从另一方面来说过度灵活意味着不可控。除此之外，类仅仅通过有限的方法暴露必要的操作，也提高类的易用性。调用者不需要了解太多背后的业务细节，用错的概率也会减少。</p>
<h3 id="抽象-Abstraction"><a href="#抽象-Abstraction" class="headerlink" title="抽象 Abstraction"></a>抽象 Abstraction</h3><p>封装主要讲的是如何隐藏信息、保护数据，而抽象讲的是如何隐藏方法的具体实现，让调用者之需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。</p>
<p>在面向对象编程中，我们常借助编程语言提供的接口类（Interface）或者抽象类（Abstract）这两种语法机制，来实现抽象。</p>
<p>抽象的意义，首先作为一种只关注功能不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息。其次，抽象在代码设计中起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则、代码解耦等。</p>
<p>我们在定义类的方法时，也要有抽象思维，不要在方法定义中暴露太多的实现细节，以保证在某个时间点需要修改方法的实现逻辑时不用去修改其定义。</p>
<h3 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承 Inheritance"></a>继承 Inheritance</h3><p>为了实现继承特性，编程语言需要提供特殊的语法机制来支持，如Java中使用extends来实现继承，C++使用冒号，Python使用paraentheses（）等。不过有些语言只支持单继承，如Java、PHP、C#、Ruby等，有些支持多重继承，如C++、python、Perl等。</p>
<p>继承存在的最大好处就是代码复用。不过过度使用继承层次过深过复杂，会导致代码可读性、可维护性变差。所以继承应该尽量少用，甚至不用。（多用组合少用继承）</p>
<h3 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态 Polymorphism"></a>多态 Polymorphism</h3><p>多态能提高代码的可扩展性和复用性。除此之外多态也是很多设计模式、设计原则、编程技巧的代码实现基础。比如策略模式、基于接口而非实现编程、依赖倒置原则、里氏替换原则、利用多态去掉冗长的if-else语句等。</p>
<h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>Java不支持继承的原因是多重继承存在副作用：钻石问题（菱形继承）</p>
<p>假设B和C都继承A，且都重写了A中同一方法，类D继承类B和类C，对于B、C重写的A中的方法，类D会继承哪一个会产生歧义。但是Java支持多接口实现，因为接口中的方法是抽象的，在实现接口时需要实现类自己实现，所以不会出现二义性问题。</p>
<h2 id="理论三：面向对象比面向过程有哪些优势？面向过程过时了吗？"><a href="#理论三：面向对象比面向过程有哪些优势？面向过程过时了吗？" class="headerlink" title="理论三：面向对象比面向过程有哪些优势？面向过程过时了吗？"></a>理论三：面向对象比面向过程有哪些优势？面向过程过时了吗？</h2><h3 id="什么是面向过程编程与面向过程编程语言？"><a href="#什么是面向过程编程与面向过程编程语言？" class="headerlink" title="什么是面向过程编程与面向过程编程语言？"></a>什么是面向过程编程与面向过程编程语言？</h3><p>面向过程编程也是一种编程范式/风格，它以过程作为组织代码的基本单元。以数据与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。<br>面向过程编程语言首先是一种编程语言。它最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性。</p>
<h3 id="面向对象编程相比面向过程编程有哪些优势？"><a href="#面向对象编程相比面向过程编程有哪些优势？" class="headerlink" title="面向对象编程相比面向过程编程有哪些优势？"></a>面向对象编程相比面向过程编程有哪些优势？</h3><h4 id="OOP更加能够应对大规模复杂程序的开发"><a href="#OOP更加能够应对大规模复杂程序的开发" class="headerlink" title="OOP更加能够应对大规模复杂程序的开发"></a>OOP更加能够应对大规模复杂程序的开发</h4><p>对于大规模复杂程序开发来说，整个程序的处理流程错综复杂，并非只有一条主线。如果用面向过程编程这种流程化、线性的思维方式，去翻译这个网状结构，去思考如何把程序拆解为一组顺序执行的方法会比较吃力。</p>
<p>面向对象编程以类为思考对象。在进行面向对象编程的时候，我们并不是一上来就去思考如何讲复杂的流程拆解为一个一个方法，而是采用曲线救国的策略。先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，完成这些工作完全不需要考虑错综复杂的处理流程。</p>
<p>除此之外，面向对象编程还提供了一种更加清晰、更加模块化的代码组织方式。</p>
<p>实际上利用面向过程的编程语言那样，也可以写出面向对象风格的代码。只不过可能会比用面向对象编程语言付出的代价更高一些。两种编程风格并不是完全对立的。</p>
<h4 id="OOP代码更易复用、易扩展、易维护"><a href="#OOP代码更易复用、易扩展、易维护" class="headerlink" title="OOP代码更易复用、易扩展、易维护"></a>OOP代码更易复用、易扩展、易维护</h4><p>封装特性是两种编程风格最基本的区别，面向对象将数据和方法绑定在一起，通过访问权限控制，只允许外部调用者通过类暴露的有限方法访问数据，而不会像面向过程那样，数据可以被任意方法修改。因此面向对象提供的封装特性更有利于提高代码的易维护性。</p>
<p>函数本身就是一种抽象，它隐藏了具体实现。我们在使用函数时之需要了解函数具有什么功能，而不需要了解它是怎么实现的。从这一点上两种编程风格都支持抽象特性。只是面向对象还提供了其他抽象特性的实现方式，如基于接口实现的抽象。基于接口的抽象可以让我们在不改变原有实现的情况下，轻松替换新的实现逻辑，提高了代码的可扩展性。</p>
<p>继承特性是面向对象特有的，能避免代码重复写很多遍，提高了代码的复用性。</p>
<p>多态特性也是面向对象特有，在需要修改一个功能实现的时候，可以通过实现一个新的子类的方式，在子类重写原来的逻辑功能。用子类替换父类遵从了“对修改关闭，对扩展开放”的原则，提高代码的扩展性。除此之外，多态特性使得不同类对象可以传递相同的方法，执行不同的逻辑，提高代码复用性。</p>
<h4 id="OOP语言更加人性化、更高级智能"><a href="#OOP语言更加人性化、更高级智能" class="headerlink" title="OOP语言更加人性化、更高级智能"></a>OOP语言更加人性化、更高级智能</h4><p>面向对象时，开发者是在思考如何给业务建模、如何将真实世界映射为类或者对象，能更聚焦到业务本身，而不是思考如何和机器打交道。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><ul>
<li>Unix/Linux这些复杂系统，也是基于C语言这种面向过程的编程语言开发的，怎么看待这种现象？<ul>
<li>操作系统是业务无关的，它更接近于底层计算机，因此更适合用面向过程的语言编写。并且和硬件打交道需要考虑到语言本身翻译成机器语言的成本和执行效率。</li>
<li>不过操作系统虽然是面向过程的C语言实现，但是其设计逻辑是面向对象的。它用结构体同样实现了信息的封装，内核源码中也不乏继承和多态思想的体现。面向对象思想并不局限于具体语言。</li>
</ul>
</li>
</ul>
<h2 id="理论四：-哪些代码设计看似面向对象，实际是面向过程的？"><a href="#理论四：-哪些代码设计看似面向对象，实际是面向过程的？" class="headerlink" title="理论四： 哪些代码设计看似面向对象，实际是面向过程的？"></a>理论四： 哪些代码设计看似面向对象，实际是面向过程的？</h2><h3 id="滥用getter、setter方法"><a href="#滥用getter、setter方法" class="headerlink" title="滥用getter、setter方法"></a>滥用getter、setter方法</h3><p>在项目开发中，有时定义完类的属性之后，就顺手将属性的getter、setter方法都定义上。IDE或者Lombok插件会自动生成所有属性的getter、setter方法。</p>
<p>这种方法是不推荐的，因为其违反了面向对象的封装特性，相当于将面向对象编程风格退化成了面向过程编程风格。 例如下面这段代码</p>
<pre><code>public class ShoppingCart {
    private int itemsCount;
    private double totalPrice;
    private List&lt;ShoppingCartItem&gt; items = new ArrayList&lt;&gt;();

    public int getItemsCount() {
        return this.itemsCount;
    }

    public void setItemCount(int itemsCount) {
        this.itemsCount = itemsCount;
    }

    public double getTotalPrice() {
        return this.totalPrice;
    }

    public void setTotalPrice(double totalPrice) {
        this.totalPrice = totalPrice;
    }

    public List&lt;ShoppingCartItem&gt; getItems() {
        return this.items;
    }

    public void addItems(ShoppingCartItem item) {
        items.add(item);
        itemCount++;
        totalPrice += item.getPrice();
    }
    ...
}
</code></pre><p>在这个代码中虽然我们将itemsCount和totalPrice定义为private，但是外部可以通过setter方法随意修改这两个属性的值。可能会导致和items属性的值不一致。暴露不该暴露的setter方法明显违反了面向对象的封装特性。数据没有任何访问权限，任何代码都可以随意修改，代码就退化成了面向过程编程风格了。</p>
<p>对于items我们没有设置setter方法，这样的设计看起来没有任何问题，而实际上并不是。items属性的getter方法返回的是一个List容器。外部调用者在拿到这个容器后，是可以操作容器内部数据的。比如obj.getItems().clear()会清空购物车，这样也会导致类属性中三个数据不一致。</p>
<p>正确的方法是应该专门在类中提供clear方法，并且修改getItems返回类型为Collections.undermidifiableList()。此时外部调用要修改就会抛出UnsupportedOperationException异常，避免容器中的数据被修改。（这里还存在一个问题，虽然items容器中数据不会被修改，但是容器中每个对象ShoppingCartItem的数据仍然可以修改）</p>
<h3 id="滥用全局变量和全局方法"><a href="#滥用全局变量和全局方法" class="headerlink" title="滥用全局变量和全局方法"></a>滥用全局变量和全局方法</h3><p>面向对象编程中，常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法。</p>
<ul>
<li>单例类对象在全局代码中只有一份，相当于全局变量</li>
<li>静态成员变量归属类上的数据，被所有实例化对象共享，也相当于一定程度上的全局变量</li>
<li>常量是非常常见的全局变量，放到一个Constant类中</li>
<li>静态方法一般用来操作静态变量或者外部数据。如各种Utils类，里面的方法一般都会定义成静态方法。静态方法将方法和数据分离，破坏了封装特性，是典型的面向过程风格。</li>
</ul>
<p>如：</p>
<pre><code>public class Constants {
    public static final String MYSQL_ADDR_KEY = &quot;mysql_addr&quot;;
    ...
}
</code></pre><p>我们会把程序中所有用到的常量都集中放到这个Constants类中，这并不是一个很好的设计思路。</p>
<ul>
<li>首先会影响代码的可维护性。开发同一项目的工程师很多，在开发过程中可能都要涉及修改这个类，查找修改可能比较费时，并且会增加提交代码冲突的概率。</li>
<li>其次，这样的设计会增加代码的编译时间。 依赖这个类的代码很多，每次修改Constants类都会导致依赖它的类重新编译。</li>
<li>最后，这样设计会影响代码的复用性。 如果我们在另一个项目中复用本项目的一个类，该类又依赖Constants类，即使只依赖其中的一部分我们仍然需要将整个Constants类也一起并入。引入许多无关的常量到新项目中。</li>
</ul>
<p>如何改进呢？</p>
<ul>
<li>将Constants类拆解为功能更加单一的多个类</li>
<li>另一种更好的思路是，并不单独地设计Constants常量类，而是哪个类用到了某个常量，就把这个常量定义到这个类中，提高了类设计的内聚性和代码的复用性</li>
</ul>
<p>对于Utils类，它的出现主要是解决了多个类需要用到一块相同的功能逻辑，为了避免代码重复。通常为了复用会通过继承特性，将相同的属性和方法提取出来，定义到父类中，子类复用父类中的属性和方法。但是有时候从业务含义上，这些类并不一定具有继承关系，仅仅为了代码复用生硬地抽象一个父类，会影响代码可读性。所以只包含静态方法Utils类就出现了，它实现了公用的方法但是不需要共享任何数据，因此不需要定义任何属性。同时也要注意不要实现大而全的Utils类，最好细化一下。</p>
<h3 id="定义数据和方法分离的类"><a href="#定义数据和方法分离的类" class="headerlink" title="定义数据和方法分离的类"></a>定义数据和方法分离的类</h3><p>传统的MVC分为Model层、Controller层、View层，在做前后端分离之后，三层结构在后端开发时会稍微有些调整，被分为Controller层、Service层、Repository层。Controller层负责暴露接口给前端调用，Service层负责核心业务逻辑，Repository层负责数据读写。在每一层中我们又会定义相应的VO（ViewObject）、BO（BusinessObject）、Entity。一般情况下VO、BO、Entity只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的Controller类、Service类、Repository类中。这就是典型的面向过程的编程风格。</p>
<p>实际上这种开发模式叫做基于贫血模型的开发模式，也就是我们现在非常常用的一种Web项目开发模式。</p>
<h3 id="面向对象编程中，为什么容易写出面向过程风格的代码？"><a href="#面向对象编程中，为什么容易写出面向过程风格的代码？" class="headerlink" title="面向对象编程中，为什么容易写出面向过程风格的代码？"></a>面向对象编程中，为什么容易写出面向过程风格的代码？</h3><p>主要是面向过程符合人的流程化思维方式。面向对象则是一种自底向上的思考方式，不是先去思考执行流程来分解任务，而是将任务翻译成一个一个的小模块，设计类之间的交互，最后按照流程将类组装起来完成整个任务。这种思考路径比较适合复杂程序开发，不是特别符合人类的思考习惯。</p>
<p>除此之外，面向对象中类的设计挺需要技巧，需要一定设计经验，要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的关系，类之间的交互等诸多问题。</p>
<p>不管使用面向过程还是面向对象，最终目的都是写出易维护、易读、易复用、易扩展的高质量代码。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，就大可不用避讳在面向对象编程中写面向过程风格的代码。</p>
<h2 id="理论五：-接口VS抽象类的区别？如何用普通的类模拟抽象类和接口？"><a href="#理论五：-接口VS抽象类的区别？如何用普通的类模拟抽象类和接口？" class="headerlink" title="理论五： 接口VS抽象类的区别？如何用普通的类模拟抽象类和接口？"></a>理论五： 接口VS抽象类的区别？如何用普通的类模拟抽象类和接口？</h2><h3 id="什么是抽象类和接口？区别在哪里？"><a href="#什么是抽象类和接口？区别在哪里？" class="headerlink" title="什么是抽象类和接口？区别在哪里？"></a>什么是抽象类和接口？区别在哪里？</h3><p>抽象类</p>
<ul>
<li>不允许被实例化，只能被继承。</li>
<li>抽象类可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现。不包含代码实现的方法叫做抽象方法。</li>
<li>子类继承抽象类，必须实现抽象类中的所有抽象方法。</li>
</ul>
<p>接口</p>
<ul>
<li>接口不能包含属性（即成员变量）</li>
<li>接口只能声明方法，方法不能包含代码实现</li>
<li>类实现接口的时候，必须实现接口中声明的所有方法</li>
</ul>
<p>抽象类实际上就是类，只不过是一种不能被实例化的特殊类，只能被子类继承，is-a的关系。接口表示has-a的关系，表示具有某些功能。对于接口，有一个更加形象的叫法，就是协议。</p>
<h3 id="抽象类和接口能解决什么编程问题？"><a href="#抽象类和接口能解决什么编程问题？" class="headerlink" title="抽象类和接口能解决什么编程问题？"></a>抽象类和接口能解决什么编程问题？</h3><p>抽象类是为代码复用而生的，多个子类可以继承抽象类中定义的属性和方法，避免在子类中重复编写相同的代码。普通的类继承虽然也可以解决代码复用问题，但是无法使用多态特性，会增加类被无用的风险。虽然也可以通过设置私有的构造函数的方式来解决，不过显然没有抽象类优雅。</p>
<p>接口更侧重于解耦，是对行为的一种抽象，相当于一组协议或者契约，可以类比API接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。</p>
<h3 id="如何模拟抽象类和接口两个语法概念？"><a href="#如何模拟抽象类和接口两个语法概念？" class="headerlink" title="如何模拟抽象类和接口两个语法概念？"></a>如何模拟抽象类和接口两个语法概念？</h3><p>我们可以通过抽象类来模拟接口。首先接口的定义：接口中没有成员变量，只有方法声明，没有方法实现，实现接口的类必须实现接口中的所有方法。</p>
<pre><code>class Strategy {
    public:
        ~Strategy();
        virtual void algorithm() = 0;
    protected:
        Strategy();
}
</code></pre><p>上述C++代码中用抽象类模拟了一个接口，类中没有定义任何属性，并且所有方法都是virtual类型。</p>
<p>除了用抽象类来模拟接口，我们还可以用普通类来模拟接口。类中虽然包含方法不符合接口定义，但是我们可以让类中的方法抛出异常来模拟不包含实现的接口，并且能强迫子类在继承这个父类的时候都去主动实现父类的方法，否则就会在运行时抛出异常。为了避免该类被实例化，我们将类的构造函数声明为protected方法就可以了。</p>
<pre><code>public class MockInterface {
    protected MockInterface() {}
    public void funcA() {
        throw new MethodUnSupportedException();
    }
} 
</code></pre><h3 id="如何决定该用抽象类还是接口？"><a href="#如何决定该用抽象类还是接口？" class="headerlink" title="如何决定该用抽象类还是接口？"></a>如何决定该用抽象类还是接口？</h3><p>要表示一种is-a的关系，并且是为了解决代码复用的问题，就用抽象类。</p>
<p>要表示一种has-a的关系，并且是为了解决抽象而非代码复用的问题，就可以使用接口。</p>
<p>抽象类是一种自下而上的设计思路，现有子类的代码重复，然后再抽象成上层的父类。而接口正好相反，它是一种自上而下的设计思路，在编程的时候一般是先设计接口再去考虑具体的实现。</p>
<h2 id="理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"><a href="#理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？" class="headerlink" title="理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？"></a>理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？</h2><p>Program to an interface, not an implematation。这句话最早出自1994年GoF的设计模式这本书，是一种比较抽象泛化的思想。此处的interface不要局限于编程语言中的接口。</p>
<p>如果落实到具体代码，这条原则中的接口可以理解为编程语言中的接口或者抽象类。</p>
<p>应用这条原则可以有效地提高代码质量，实现接口和实现相分离，封装不稳定的实现，暴露稳定的接口。当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</p>
<ul>
<li>函数的命名不能暴露任何实现细节</li>
<li>封装具体的实现细节</li>
<li>为实现类定义抽象的接口，具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程。</li>
</ul>
<p>总之，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节，接口的定义只表明做什么，而不是怎么做。而且在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，能否做到在替换具体的接口实现的时候，不需要任何接口定义的改动。</p>
<h3 id="是否要为每个类定义接口？"><a href="#是否要为每个类定义接口？" class="headerlink" title="是否要为每个类定义接口？"></a>是否要为每个类定义接口？</h3><p>如果业务场景中某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那么我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以。</p>
<h2 id="理论七：为什么要多用组合少用继承？如何决定该用组合还是继承？"><a href="#理论七：为什么要多用组合少用继承？如何决定该用组合还是继承？" class="headerlink" title="理论七：为什么要多用组合少用继承？如何决定该用组合还是继承？"></a>理论七：为什么要多用组合少用继承？如何决定该用组合还是继承？</h2><h3 id="为什么不推荐用继承？"><a href="#为什么不推荐用继承？" class="headerlink" title="为什么不推荐用继承？"></a>为什么不推荐用继承？</h3><p>比如，我们设计一个关于鸟的类AbstractBird，所有细分的鸟都继承这个抽象类。 大部分鸟都可以飞，我们可不可以在抽象类中定义fly()方法呢？答案是不行，因为还有特例，如果我们对所有不会飞的鸟都重写fly方法并且抛出异常也可行，但是不够优雅。一方面增加了代码量另一方面也违背的Least Knowledge Principle（最小知识原则/迪米特法则），暴露了不该暴露的接口给外部，增加了类使用过程中被误用的概率。</p>
<p>此时再通过抽象类派生出两个细分的类，AbstractFlyableBird/AbstractUnFlyableBird()，这样继承关系就变成3层。如果此时再关注鸟会不会叫等等特点，继承关系就会越来越复杂，导致代码可读性变差。也破坏了类的封装特性，将父类的实现细节暴露给子类，子类的实现依赖父类的实现，两者高度耦合，一旦父类代码修改就会影响所有子类的逻辑。</p>
<h3 id="组合相比继承有哪些优势？"><a href="#组合相比继承有哪些优势？" class="headerlink" title="组合相比继承有哪些优势？"></a>组合相比继承有哪些优势？</h3><p>我们可以利用组合Composition、接口、委托delegation三个技术手段，一起解决刚刚继承存在的问题。</p>
<p>接口表示某种行为特性，针对会飞特性我们可以定义Flyable接口，只让会飞的鸟去实现这个接口，对于会叫、会下蛋这些行为特性，类似定义Tweetable接口、EggLayable接口。不过接口只声明方法，不定义实现，也就是所有会下蛋的类都要实现一遍LayEgg()方法，会导致代码重复的问题。</p>
<p>我们可以针对三个接口再定义三个实现类，通过组合和委托技术来消除代码重复。</p>
<pre><code>public interface Flyable() {
    void fly();
}
public class FlyAbility implements Flyable {
    @Override
    public void fly() {...}
}
...

public class Ostrich implements Tweetable, Egglayable {
    private TweetAbility tweetAbility = new TweetAbility();
    private EggLayAbility eggLayAbility = new EggLayAbility();

    @Overide 
    public void tweet() {
        tweetAbility.tweet();
    }

    @Overide
    public void layEgg() {
        eggLayAbility.layEgg();
    }
}
</code></pre><h3 id="如何判断该用组合还是继承？"><a href="#如何判断该用组合还是继承？" class="headerlink" title="如何判断该用组合还是继承？"></a>如何判断该用组合还是继承？</h3><p>如果类之间的继承结构稳定，继承层次比较浅（最多两层），继承关系不复杂我们就可以大胆使用继承。反之则尽量使用组合。</p>
<p>有一些设计模式会固定使用继承或组合：</p>
<ul>
<li>装饰者模式decorator pattern、策略模式Strategy pattern、组合模式Composite pattern都使用了组合关系</li>
<li>模版模式template pattern则使用了继承关系</li>
</ul>
<p>还有一些特殊场景必须使用继承。如果不能改变函数的入参类型，而入参又非接口，为了支持多态只能采用继承来实现。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Frances Hu" />
          <p class="site-author-name" itemprop="name">Frances Hu</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">40</span>
              <span class="site-state-item-name">Artikel</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">Tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Frances Hu</span>
</div>

<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
